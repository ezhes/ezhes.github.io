<!doctype html><html lang=en><head><title>Benchmarking Popular Markdown Parsers on iOS :: Ezhes — tale of the tailed z</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Reddit uses markdown for all of its posts and comments and so I needed a way to parse and render markdown not only well but fast. In the two years I&amp;rsquo;ve been working on this app of and on I&amp;rsquo;ve went through multiple differently libraries before I decided it&amp;rsquo;d be worthwhile to actually go and find the best one once and for all instead of just trying random ones, and so I decided to benchmark the top five I could find."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://ezh.es/blog/1/01/benchmarking-popular-markdown-parsers-on-ios/><link rel=stylesheet href=https://ezh.es/blog/assets/style.css><link rel=stylesheet href=https://ezh.es/blog/assets/pink.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://ezh.es/blog/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://ezh.es/blog/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="ezhes_"><meta name=twitter:creator content="Allison Husain"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Benchmarking Popular Markdown Parsers on iOS :: Ezhes"><meta property="og:description" content="Reddit uses markdown for all of its posts and comments and so I needed a way to parse and render markdown not only well but fast. In the two years I&amp;rsquo;ve been working on this app of and on I&amp;rsquo;ve went through multiple differently libraries before I decided it&amp;rsquo;d be worthwhile to actually go and find the best one once and for all instead of just trying random ones, and so I decided to benchmark the top five I could find."><meta property="og:url" content="https://ezh.es/blog/1/01/benchmarking-popular-markdown-parsers-on-ios/"><meta property="og:site_name" content="Benchmarking Popular Markdown Parsers on iOS"><meta property="og:image" content="https://ezh.es/blog/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/blog><div class=logo>Ʒ</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=https://github.com/shusain93>Github</a></li><li><a href=https://twitter.com/ezhes_>Twitter</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://github.com/shusain93>Github</a></li><li><a href=https://twitter.com/ezhes_>Twitter</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://ezh.es/blog/1/01/benchmarking-popular-markdown-parsers-on-ios/>Benchmarking Popular Markdown Parsers on iOS</a></h1><div class=post-meta><span class=post-author>::
Allison Husain</span></div><span class=post-tags>#<a href=https://ezh.es/blog/tags/ios/>iOS</a>&nbsp;
#<a href=https://ezh.es/blog/tags/performance/>performance</a>&nbsp;</span><div class=post-content><div><p>Reddit uses markdown for all of its posts and comments and so I needed a way to parse and render markdown not only well but <em>fast</em>. In the two years I&rsquo;ve been working on this app of and on I&rsquo;ve went through multiple differently libraries before I decided it&rsquo;d be worthwhile to actually go and find the best one once and for all instead of just trying random ones, and so I decided to benchmark the top five I could find.</p><p><strong>TL;DR</strong>: Use <a href=https://github.com/HowdyHub/CocoaMarkdown>CocoaMarkdown</a>. Skip to the end for a summary.</p><h2 id=test-methodology>Test Methodology<a href=#test-methodology class=hanchor arialabel=Anchor>&#8983;</a></h2><p>I&rsquo;m collecting two bits of data:</p><ol><li>How long it takes to complete 1000 full cycles (source text to display)</li><li>How much memory is uses max (and how much is leaked)</li></ol><p>The library needs to be able to either take its source as HTML or markdown. I can do this because Reddit actually (for whatever reason) provides both HTML and markdown with every API request, wasting user&rsquo;s bandwidth everywhere.</p><p><img src=/blog/images/markdown_ios_benchmarks/markdown_html_reddit.png alt=/blog/images/markdown_ios_benchmarks/markdown_html_reddit.png></p><p><a href=https://www.reddit.com/r/reddit.com/comments/6ewgt/reddit_markdown_primer_or_how_do_you_do_all_that/c03nik6/>This is the markdown/HTML sample I&rsquo;m using. It&rsquo;s long and has lots of weird formatting. It even makes Chrome stutter when rendering.</a></p><p>To test timing I used the following methods to time a code block:</p><p><em>Objective C</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>-(<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>totalRuntimeForMethod:</span>(NSString<span style=color:#f92672>*</span>)method <span style=color:#a6e22e>block:</span>(<span style=color:#66d9ef>void</span>(<span style=color:#f92672>^</span>)(<span style=color:#66d9ef>void</span>))block;
{
    <span style=color:#66d9ef>extern</span> uint64_t dispatch_benchmark(size_t count, <span style=color:#66d9ef>void</span> (<span style=color:#f92672>^</span>block)(<span style=color:#66d9ef>void</span>));
    
    <span style=color:#66d9ef>int</span> iterations <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>;
    uint64_t t <span style=color:#f92672>=</span> dispatch_benchmark(iterations, <span style=color:#f92672>^</span>{
        <span style=color:#66d9ef>@autoreleasepool</span> {
            block();
        }
    });
    
    NSLog(<span style=color:#e6db74>@&#34;Runtime for %i iterations (ms) %@: %f&#34;</span>, iterations, method, t<span style=color:#f92672>/</span><span style=color:#ae81ff>1000000.0</span><span style=color:#f92672>*</span>iterations);
}
</code></pre></div><p><em>Swift</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>measure</span>(<span style=color:#66d9ef>_</span> title: String, block: (() -&gt; ())) {
    <span style=color:#66d9ef>let</span> startTime = CFAbsoluteTimeGetCurrent()
    <span style=color:#66d9ef>let</span> iterations = <span style=color:#ae81ff>500</span>
    
    <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0.</span>.<span style=color:#f92672>&lt;</span>(iterations) {
        block()
    }
    <span style=color:#66d9ef>let</span> timeElapsed = (CFAbsoluteTimeGetCurrent() <span style=color:#f92672>-</span> startTime) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>
    print(<span style=color:#e6db74>&#34;Runtime for </span><span style=color:#e6db74>\(</span>iterations<span style=color:#e6db74>)</span><span style=color:#e6db74> iterations (ms) </span><span style=color:#e6db74>\(</span>title<span style=color:#e6db74>)</span><span style=color:#e6db74>: </span><span style=color:#e6db74>\(</span>timeElapsed<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
}
</code></pre></div><p>All tests were performed on an iPhone X running iOS 11.2</p><h2 id=the-apple-way-nsattributedstring----html>The Apple Way (<code>NSAttributedString</code>) &ndash; HTML<a href=#the-apple-way-nsattributedstring----html class=hanchor arialabel=Anchor>&#8983;</a></h2><p>iOS offers a nice looking native way to convert HTML (with very good CSS!) into <code>NSAttributedString</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>[self totalRuntimeForMethod:<span style=color:#e6db74>@&#34;NSAttributedStringHTML&#34;</span> block:<span style=color:#f92672>^</span>{
    NSDictionary <span style=color:#f92672>*</span>options <span style=color:#f92672>=</span> <span style=color:#ae81ff>@{</span> NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType <span style=color:#ae81ff>}</span>;
    NSAttributedString <span style=color:#f92672>*</span>attrStr <span style=color:#f92672>=</span> [[NSAttributedString alloc] initWithData:[html dataUsingEncoding:NSUTF8StringEncoding] options:options documentAttributes:NULL error:NULL];
    
    
    UITextView <span style=color:#f92672>*</span>textView <span style=color:#f92672>=</span> [[UITextView alloc]initWithFrame:self.view.frame textContainer:nil];
    [self.view addSubview:textView];
    textView.attributedText <span style=color:#f92672>=</span> attrStr;
    [textView layoutSubviews];
    
    [textView removeFromSuperview];
}];
</code></pre></div><p>It renders it very well but this comes at a cost.</p><p><code>Runtime for 1000 iterations (ms) NSAttributedStringHTML: 88583.218000</code></p><p>It&rsquo;s dreadfully slow. This is the method I used initially and it was most certainly not capable of just in time rendering, especially when trying to quickly scroll through reddit comments.</p><p>In terms of memory usage though, the Apple way is very good. It leaked 10.7MB which is the highest leaked by any of the libraries.</p><p><img src=/blog/images/markdown_ios_benchmarks/NSAttributedString_5000.png alt=/blog/images/markdown_ios_benchmarks/NSAttributedString_5000.png></p><p>A note about reading these graphs: I left some time before starting the benchmark and then some after to let ARC and the OS try and free memory or whatever. The initial memory usage of this empty app is 17.3MB.</p><h2 id=dtcoretexthttpsgithubcomcocoaneticsdtcoretext----html><a href=https://github.com/Cocoanetics/DTCoreText>DTCoreText</a> &ndash; HTML<a href=#dtcoretexthttpsgithubcomcocoaneticsdtcoretext----html class=hanchor arialabel=Anchor>&#8983;</a></h2><p>I implemented this in my app after a few months of suffering through <code>NSAttributedString</code>&rsquo;s slowness. DTCoreText is both an HTML+CSS parser as well as a CoreText display engine, offering their own <code>DTAttributedTextView</code>. Unfortunately, the CSS parser here is quite a bit worse and doesn&rsquo;t support a lot of the same styling as Apple does. Despite this, it&rsquo;s a bit faster and I used it in my app for a year.</p><p>For DTCoreText I tested both their parser with <code>UITextView</code> and <code>DTAttributedTextView</code>.</p><p><em>UITextView</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>[self totalRuntimeForMethod:<span style=color:#e6db74>@&#34;DTCore&#34;</span> block:<span style=color:#f92672>^</span>{
    UITextView <span style=color:#f92672>*</span>textView <span style=color:#f92672>=</span> [[UITextView alloc]initWithFrame:self.view.frame textContainer:nil];
    DTHTMLAttributedStringBuilder <span style=color:#f92672>*</span>builder <span style=color:#f92672>=</span> [[DTHTMLAttributedStringBuilder alloc]initWithHTML:[html dataUsingEncoding:NSUTF8StringEncoding] options:<span style=color:#ae81ff>@{</span>DTUseiOS6Attributes : @true<span style=color:#ae81ff>}</span> documentAttributes:nil];
    NSAttributedString <span style=color:#f92672>*</span>generatedString <span style=color:#f92672>=</span> [builder generatedAttributedString];
    [self.view addSubview:textView];
    textView.attributedText <span style=color:#f92672>=</span> generatedString;
    [textView layoutSubviews];
    
    [textView removeFromSuperview];
}];
</code></pre></div><p><code>Runtime for 1000 iterations (ms) DTCore UITextView: 72529.906000</code></p><p>DTCoreText + UITextView finished a full 16 seconds sooner than <code>NSAttributedString</code>! It still did take 72.5 seconds but we&rsquo;ll ignore that for now.</p><p>Memory is great here. Lower max memory than Apple, and it only leaked 4.3MB!</p><p><img src=/blog/images/markdown_ios_benchmarks/DTCoreText_1000.png alt=/blog/images/markdown_ios_benchmarks/DTCoreText_1000.png></p><p><em>DTAttributedTextView</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>[self totalRuntimeForMethod:<span style=color:#e6db74>@&#34;DTCore&#34;</span> block:<span style=color:#f92672>^</span>{
    DTAttributedTextView <span style=color:#f92672>*</span> textView <span style=color:#f92672>=</span> [[DTAttributedTextView alloc]initWithFrame:self.view.frame];
    DTHTMLAttributedStringBuilder <span style=color:#f92672>*</span>builder <span style=color:#f92672>=</span> [[DTHTMLAttributedStringBuilder alloc]initWithHTML:[html dataUsingEncoding:NSUTF8StringEncoding] options:<span style=color:#ae81ff>@{</span>DTUseiOS6Attributes : @true<span style=color:#ae81ff>}</span> documentAttributes:nil];
    NSAttributedString <span style=color:#f92672>*</span>generatedString <span style=color:#f92672>=</span> [builder generatedAttributedString];
    [self.view addSubview:textView];
    textView.attributedString <span style=color:#f92672>=</span> generatedString;
    [textView layoutSubviews];
    
    [textView removeFromSuperview];
}];
</code></pre></div><p><code>Runtime for 1000 iterations (ms) DTCore w/ DTAttributedTextView: 101960.893000</code></p><p>This was actually a bit of a surprise. I did not expect them to create their own text view system and ship it, knowing that it was actually SLOWER than the regular text view.</p><p>Memory wasn&rsquo;t bad either but it was worse than using UITextView. 8.5MB leaked, 28.8MB max.</p><p><img src=/blog/images/markdown_ios_benchmarks/DTCore_DTAttributedTextView_1000.png alt=/blog/images/markdown_ios_benchmarks/DTCore_DTAttributedTextView_1000.png></p><h2 id=down-swifthttpsgithubcomiwasrobbeddown----markdown><a href=https://github.com/iwasrobbed/Down>Down (Swift)</a> &ndash; Markdown<a href=#down-swifthttpsgithubcomiwasrobbeddown----markdown class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This is the first raw markdown parser I tested. I figured it&rsquo;d be faster parsing markdown directly rather than HTML because markdown is much tighter and you don&rsquo;t have to parse CSS as well.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>measure(<span style=color:#e6db74>&#34;Down&#34;</span>) {
    <span style=color:#66d9ef>let</span> down = Down.<span style=color:#66d9ef>init</span>(markdownString: markdown);
    <span style=color:#66d9ef>let</span> attributedString = <span style=color:#66d9ef>try</span>? down.toAttributedString();
    <span style=color:#66d9ef>let</span> textView = UITextView.<span style=color:#66d9ef>init</span>(frame: <span style=color:#66d9ef>self</span>.view.frame, textContainer: <span style=color:#66d9ef>nil</span>);
    <span style=color:#66d9ef>self</span>.view.addSubview(textView)
    textView.attributedText = attributedString!
    textView.layoutSubviews()
    textView.removeFromSuperview()
}
</code></pre></div><p>and it didn&rsquo;t finish 1000 rounds, it ran out of memory. Ouch. Rather than give Down a straight F, I dropped it down to 500 rounds</p><iframe src=https://gfycat.com/ifr/ColossalHugeCicada frameborder=0 scrolling=no allowfullscreen data-hd=true></iframe>
(switch on HD, gfycat is weird)<p><code>Runtime for 500 iterations (ms) Down: 23523.5600471497</code>. Assuming it scaled properly to 1000 rounds, this would be 47,047ms which is unequivocally better than DTCoreText and everything that came before it. But what&rsquo;s it doing with all this memory?</p><p>The 500 round graph does shed some light on this</p><p><img src=/blog/images/markdown_ios_benchmarks/Down_500.png alt=/blog/images/markdown_ios_benchmarks/Down_500.png></p><p>The graph spikes up to 1.12GB of usage but manages to drop all the way back down to 104MB. It&rsquo;s leaking quite a bit of memory but there&rsquo;s a much bigger problem going on too. I tossed it up into instruments and checked out the heap in the middle of one session (before it started releasing data):</p><p><img src=/blog/images/markdown_ios_benchmarks/Down_memory_alloc.png alt=/blog/images/markdown_ios_benchmarks/Down_memory_alloc.png></p><p>It&rsquo;s like this for ages. From this snapshot we can determine quite a lot about how Down works. Firstly, it&rsquo;s not <code>cmark</code> (the markdown processor written in C) causing the memory issues as I initially suspected. I thought that there was something funky going own between C->Objective-C->Swift with ARC since that&rsquo;s a lot of ground to cover. Secondly, Down is parsing Markdown into HTML and then into AttributedText <em>for some reason</em>. This HTML parsing stage is somehow faster twice as fast as Apple but it obviously has issues.</p><p>Despite this, <code>Down</code> <em>is faster than all of the above</em> but they completely messed up the memory. I&rsquo;m not sure how this will fare in a tableview where it will have down time to free memory vs. a continuous benchmark since I&rsquo;m not going to bother implementing this since I will not use it.</p><h2 id=bypasshttpsgithubcomuncodinbypass-ios----markdown><a href=https://github.com/Uncodin/bypass-ios>Bypass</a> &ndash; Markdown<a href=#bypasshttpsgithubcomuncodinbypass-ios----markdown class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This one was a doozy to implement. It&rsquo;s five years old and doesn&rsquo;t support Auto Layout in any sense and the Cocoapod is a bit broken due to the fact that this library uses ObjC and ObjC++. I implemented this one in my app (by mistake, because initially I screwed up the benchmarks). The code though is quite painful to work with. There are some methods featuring a comment of &ldquo;DON&rsquo;T TOUCH UNLESS YOU FULLY UNDERSTAND WHAT&rsquo;S GOING ON&rdquo;.</p><p>Still though, Bypass is awesome. It support async rendering of text, which I didn&rsquo;t initially realize and caused my benchmarks for 1000 rounds to seem to only take 65ms. This 65ms however really was just the amount of time it took Bypass to dispatch the parse and draw and not actually the full amount of time required to render it. What initially drew me to Bypass was that fact that it uses its own parser and display view. It does not output to AttributedText at all, and it never drops to HTML or any intermediates and instead draws markdown directly using CoreText.</p><p>Note that this library also has some weird bugs with the way it attributes text at the end of a line. For whatever reason it refuses to apply formatting to the last character of any line.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>[self totalRuntimeForMethod:<span style=color:#e6db74>@&#34;Bypass&#34;</span> block:<span style=color:#f92672>^</span>{
    BPMarkdownView <span style=color:#f92672>*</span>markdownView <span style=color:#f92672>=</span> [[BPMarkdownView alloc] initWithFrame:self.view.frame];
    [markdownView setMarkdown:markdownToRender];
    [[self view] addSubview:markdownView];
    <span style=color:#75715e>//FORCE BYPASS TO RENDER THE VIEW
</span><span style=color:#75715e></span>    [markdownView layoutSubviews];
    [markdownView removeFromSuperview];
}];
</code></pre></div><p>Note that I have to call <code>layoutSubviews</code>. Bypass doesn&rsquo;t bother doing anything until it&rsquo;s absolutely necessary unlike the other libraries.</p><p><code>Runtime for 1000 iterations (ms) Bypass: 21078.243000</code></p><p>Half the time of <code>Down</code> but it doesn&rsquo;t destroy the memory!</p><p><img src=/blog/images/markdown_ios_benchmarks/Bypass_1000.png alt=/blog/images/markdown_ios_benchmarks/Bypass_1000.png></p><p>3.7MB leaked. It also seems to have the same issue as <code>Down</code> where memory linearly increases with time instead of being perfectly flat throughout the benchmark. I believe that if I did a million or so rounds it may run out of memory but I don&rsquo;t have the time to bother testing that one. I don&rsquo;t consider this memory increase to be an issue since it only allocated 14MB on to the heap for 1000 rounds.</p><h2 id=cocoamarkdownhttpsgithubcomhowdyhubcocoamarkdowngit----markdown><a href=https://github.com/HowdyHub/CocoaMarkdown.git>CocoaMarkdown</a> &ndash; Markdown<a href=#cocoamarkdownhttpsgithubcomhowdyhubcocoamarkdowngit----markdown class=hanchor arialabel=Anchor>&#8983;</a></h2><p>CocoaMarkdown renders to <code>NSAttributedString</code> which you are then supposed to put into a <code>UITextView</code>. It also uses <code>cmark</code> for parsing. It doesn&rsquo;t work though with Unicode though so if you need that keep this in mind.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objectivec data-lang=objectivec>[self totalRuntimeForMethod:<span style=color:#e6db74>@&#34;CocoaMarkdown&#34;</span> block:<span style=color:#f92672>^</span>{
    CMDocument <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> [[CMDocument alloc]initWithData:[markdownToRender dataUsingEncoding:NSUTF8StringEncoding] options:CMDocumentOptionsSmart];
    CMTextAttributes <span style=color:#f92672>*</span>c <span style=color:#f92672>=</span> [[CMTextAttributes alloc]init];
    NSAttributedString <span style=color:#f92672>*</span>str <span style=color:#f92672>=</span> [[[CMAttributedStringRenderer alloc]initWithDocument:d attributes:c] render];
    
    UITextView <span style=color:#f92672>*</span>textView <span style=color:#f92672>=</span> [[UITextView alloc]initWithFrame:self.view.frame textContainer:nil];
    [self.view addSubview:textView];
    textView.attributedText <span style=color:#f92672>=</span> str;
    [textView layoutSubviews];
    
    [textView removeFromSuperview];
    
}];
</code></pre></div><p><code>Runtime for 1000 iterations (ms) CocoaMarkdown: 8697.179000</code></p><p>A full 12 seconds over <code>Bypass</code>. I was blown away by this. This is less than a eight milliseconds to parse and layout. There is no multithreaded trickery going on here. The attribution looks nice, the formatting class is extensible and easy to read, and it attributes most things correctly. None of these libraries, for whatever reason, support superscript but that isn&rsquo;t hard to add. I&rsquo;ll be making a pull request for Cocoamarkdown in the future to add this upstream.</p><p>To confirm my findings and validate my benchmarking system across both languages, I ran this same test in Swift:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>measure(<span style=color:#e6db74>&#34;CocoaMarkdown&#34;</span>) {
    [<span style=color:#66d9ef>unowned</span> <span style=color:#66d9ef>self</span>] <span style=color:#66d9ef>in</span>
    <span style=color:#66d9ef>let</span> doc = CMDocument.<span style=color:#66d9ef>init</span>(string: markdown, options: CMDocumentOptions.smart)
    <span style=color:#66d9ef>let</span> attributedString = CMAttributedStringRenderer.<span style=color:#66d9ef>init</span>(document: doc, attributes: CMTextAttributes.<span style=color:#66d9ef>init</span>()).render()
    <span style=color:#66d9ef>let</span> textView = UITextView.<span style=color:#66d9ef>init</span>(frame: <span style=color:#66d9ef>self</span>.view.frame, textContainer: <span style=color:#66d9ef>nil</span>);
    <span style=color:#66d9ef>self</span>.view.addSubview(textView)
    textView.attributedText = attributedString
    textView.layoutSubviews()
    textView.removeFromSuperview()
}
</code></pre></div><p><code>Runtime for 1000 iterations (ms) CocoaMarkdown (swift): 8497.15805053711 ms</code></p><p>Very close timings. I attribute the difference of 200ms to external CPU load and memory availability. Regardless, it confirms that the Swift and Objective-C tests are almost nearly identical.</p><p>In terms of memory usage, all is good (when using Objective-C). Leaking only 1.2MB on the Objective-C test and maxing out at 20.3 MB used, it also wins the memory usage metric.</p><p><img src=/blog/images/markdown_ios_benchmarks/Cocoamarkdown1000.png alt=/blog/images/markdown_ios_benchmarks/Cocoamarkdown1000.png></p><p>For some reason, memory management goes a bit sideways on Swift. I have no idea <em>what</em> Swift is doing to manage to turn 20.3MB max into 262MB but somehow it did. I don&rsquo;t think this is <code>CocoaMarkdown</code>&rsquo;s fault at all. Something weird is going on with the Swift runtime and the way it handles the memory of Objective-C functions.</p><p><img src=/blog/images/markdown_ios_benchmarks/Cocoamarkdown_1000Swift.png alt=/blog/images/markdown_ios_benchmarks/Cocoamarkdown_1000Swift.png></p><p>This appears to be the same issue which plagues <code>Down</code> however since <code>CocoaMarkdown</code> uses less memory per round it gets away with it a bit longer. I can do 4000 rounds successfully despite this issue, though with a terrifying memory graph:</p><p><img src=/blog/images/markdown_ios_benchmarks/Cocoamarkdown4000swift.png alt=/blog/images/markdown_ios_benchmarks/Cocoamarkdown4000swift.png></p><p>and again on Objective-C we see nothing of the sort and max out at a happy 28.7MB.</p><p><img src=/blog/images/markdown_ios_benchmarks/Cocoamarkdown4000objc.png alt=/blog/images/markdown_ios_benchmarks/Cocoamarkdown4000objc.png></p><p>##Summary
If you need performance, CocoaMarkdown is unbeatable. It&rsquo;s fastest and most memory efficient (* despite Swift being weird) and it works well.</p><p><strong>Raw speed</strong>:</p><table><thead><tr><th>Library</th><th>Time (ms)</th><th>Speed difference over previous</th></tr></thead><tbody><tr><td>CocoaMarkdown (UITextView)</td><td>8497</td><td>2.48x</td></tr><tr><td>Bypass (BPMarkdownView)</td><td>21078</td><td>2.23x</td></tr><tr><td>Down (UITextView) *expected</td><td>47047</td><td>1.54x</td></tr><tr><td>DTCore (UITextView)</td><td>72529</td><td>1.22x</td></tr><tr><td>NSAttributedString (UITextView)</td><td>88583</td><td>1.15x</td></tr><tr><td>DTCore (DTAttributedTextView)</td><td>101960</td><td>n/a, no worse result</td></tr></tbody></table><br><p>Dramatic to say the least. Some fun stats:</p><ul><li>CocoaMarkdown is ~12x faster than DTCore + DTAttributedTextView</li><li>CocoaMarkdown is ~10.4x faster than NSAttributedStringHTML</li></ul><hr><p><strong>Peak memory usage/max leaked (Swift results excluded due to bugginess)</strong>:</p><table><thead><tr><th>Library</th><th>Peak usage (MB)</th><th>Max leaked (MB)</th></tr></thead><tbody><tr><td>CocoaMarkdown (UITextView)</td><td>20.3</td><td>1.2</td></tr><tr><td>DTCore (UITextView)</td><td>23.9</td><td>4.3</td></tr><tr><td>DTCore (DTAttributedTextView)</td><td>28.8</td><td>8.5</td></tr><tr><td>Bypass (BPMarkdownView)</td><td>31.3</td><td>3.7</td></tr><tr><td>NSAttributedString (UITextView)</td><td>35.9</td><td>10.7</td></tr></tbody></table><hr><p>Nothing really ground breaking here in terms of Objective-C however these results are amplified by about nine fold when used in Swift, for whatever reason. Unfortunately memory doesn&rsquo;t seem to be managed very well through Objective-C bridging. If you need perfect performance you&rsquo;ll still have to stay on Objective-C for now, until at least someone writes a 100% swift Markdown library from scratch.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://ezh.es/blog/2018/06/raspberry-pi-iot-air-conditioner/><span class=button__icon>←</span>
<span class=button__text>Raspberry Pi IOT Air Conditioner</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2021 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://ezh.es/blog/assets/main.js></script><script src=https://ezh.es/blog/assets/prism.js></script></div></body></html>